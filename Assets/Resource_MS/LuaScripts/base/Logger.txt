-----
----- Generated by EmmyLua(https://github.com/EmmyLua)
----- Created by liuyubao.
----- DateTime: 2021/11/25 15:03
-----

---@class Logger
Logger = {}

local isLogEnable = true
local isUserUnityLog = false

local MAX_TABLE_DEEP = 8

function Logger.Log(...)
    if not isLogEnable then
        return
    end
    local temp = ""
    for k,v in ipairs({...})
    do
        temp = temp..tostring(v)
    end
    --temp = temp.."\n" .. debug.traceback()
    LC.Log(temp)
end

function Logger.Error(...)
    if not isLogEnable then
        return
    end
    -- if not CS.GameSetting.hasLog then
    --   return
    -- end

    local temp = "LUA_LOG->"
    for k,v in ipairs({...})
    do
        temp = temp ..tostring(v)
    end
    --temp = temp.."\n" .. debug.traceback()
    LC.Error(temp)
end

function Logger.Warning(...)

    if not isLogEnable then
        return
    end

    local temp = ""
    for k,v in ipairs({...})
    do
        temp = temp ..tostring(v)
    end
    --temp = temp.."\n" .. debug.traceback()
    LC.Warning(temp)
end


function Logger.log(...)
    Logger.Log(...)
end

function Logger.error(...)
    Logger.Error(...)
end

function Logger.warning(...)
    Logger.Warning(...)
end

function Logger.LogTable(table)
    if not isLogEnable then
        return
    end
   Logger.Log(Logger.printTable(false,table,"","",0,{}))
end

function Logger.ErrorTable(table)
    if not isLogEnable then
        return
    end
    Logger.Error(Logger.printTable(false,table,"","",0,{}))
end

function Logger.WarningTable(table)
    if not isLogEnable then
        return
    end
    Logger.Warning(Logger.printTable(false,table,"","",0,{}))
end

-- 循环打印table
---@generic V : any
---@param str string @ 最后总的msg
---@param key string @ 要打印的tbl的key （当tbl在其他table中出现的时候）
---@param tbl table<string, V>
---@param ex string @ 是行首缩进
---@param layer number @ 当前递归深度
---@param repeate table @ 用来判断某个table是否要被重复打印
 function Logger.printTable(key, tbl, str, ex, layer, repeate)
    local childTable = {}

    ---@type string
    local nextEx = ex .. "\t"
    if key then
        --  如果tbl是在其他table中出现
        -- 打印{
        str = string.format("%s%s%s={ ", str, ex, key)
    else
        -- tbl是要打印的初始的table
        -- 打印{
        str = string.format("%s%s{ ", str, ex)
    end
    tbl = tbl or {}
    -- 如果tbl非空
    if tbl and next(tbl) then
        local isFull = layer >= MAX_TABLE_DEEP
        for k, v in pairs(tbl) do
            if type(v) ~= "table" or isFull then
                str = string.format("%s\n %s %s = %s, ", str, nextEx, k, tostring(v) )
            else
                -- 是table，而且没有isFull

                -- 判断是否打印过此table
                if repeate[v] then
                    str = string.format("%s\n %s %s = %s, ", str, nextEx, k, tostring(v))
                else
                    childTable[k] = v
                end
            end
        end

        --printOrig("printTable"..str.."  1"..layer.." max:"..MAX_TABLE_DEEP)
        -- 打印table类型的孩子
        for k, v in pairs(childTable) do
            repeate[v] = true
            ---@generic V
            ---@type table<string, V>
            local vv = v
            str = Logger.printTable(k, vv, str .. "\n", nextEx, layer + 1, repeate)
        end
        str = str .. "\n" .. ex .. "},"
    else
        str = str .. " },"
    end

    return str
end

