---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2022/1/6 20:52
---@class SkillData
local SkillData = SimpleClassUtil:class()

function SkillData:initialize(con,supplementaryData)
    self:initParams(con,supplementaryData)
end

function SkillData:initParams(con,supplementaryData)
    self._skillTag = con.skillId
    -- 大招 还是 普攻 还是 普通技能
    self._skillPosition = con.position
    -- 数值表数值
    self._skillCon = con
    -- 上次释放时间
    self._skill_time_play = 0
    -- 技能类型
    self._skillType = con.type
    -- 是否被动
    self._isPassive = (con.type == Enum_Battle.SkillType.Skill_passive) or (con.type == Enum_Battle.SkillType.Skill_cCalled)

    -------------------------------

    -- 技能释放的消耗
    self._skillCost = con.cost or nil
    -- 释放释放得条件 怒气 -- 目前是约定得只有大招才需要怒气 而且是 常量 1000
    self._skill_need_power = con.position == Enum_Battle.SkillTag.Skill_1 and BattleConstant.SkillLaunchEnergy or 0
    -- 技能释放得特殊条件
    self._condition = con.condition or nil
    -- 技能释放得范围判断类型条件
    self._skill_launch_ranger_type = con.rangeType or Enum_Battle.SkillLaunchRangeType.Passive
    --技能释放的范围
    self._skill_launch_ranger_params = con.range
    --技能释放的目标类型
    self._skill_launch_target_type = con.targetType
    -- 普攻攻击距离
    self._skill_r = con.type == Enum_Battle.SkillType.Skill_a and con.range[1] or 0
    -- 技能cd
    self._skill_time_cd = con.cd2 and con.cd2 * 1000 or 0
    -- 初始前置技能cd
    self._skill_time_initCd = con.cd1 and con.cd1 * 1000 or 0
    -- Gcd
    self._skill_gCd = con.gcd and con.gcd * 1000 or 0
    -- 释放时增加的怒气
    self._skill_add_anger = con.addPower or 0
    -- 是否是蓄力
    self._isStoreUp = (con.isSing and con.isSing == 1) or false
    -- 是否持续施法
    self._isSpell =  (con.isSpell and con.isSpell == 1) or false
    -- 持续施法中满怒是否立刻放大
    self._spellUltra = (con.spellUltra and con.spellUltra == 1) or false
    -- 是否无视异常状态
    self._unstoppable = (con.unstoppable and con.unstoppable == 1) or false


    -- 前摇结束帧
    self._frontHalfFrame = con.frontHalf or 0
    -- 后摇开始帧
    self._behindHalfFrame = con.behindHalf or 0
    -- 前摇是否可以被打断
    self._canBreak_forward = con.canBreak1 and con.canBreak1 == 1 or false
    -- 后摇是否可以被打断
    self._canBreak_back = con.canBreak2 and con.canBreak2 == 1 or false
    -- 结束帧
    self._endFrame = con.endFrame or 0
    -- 特殊参数
    self._specialParam = con.param
    -- 帧事件map
    self._timeLineMap = self:handleTimeLineMap(con,supplementaryData)


end

function SkillData:handleTimeLineMap(con,supplementaryData)
    if con.type == Enum_Battle.SkillType.Skill_special then
        return supplementaryData.timeLineMap
    end
    -- 被动 或者 是 被调用
    if (con.type == Enum_Battle.SkillType.Skill_passive) or (con.type == Enum_Battle.SkillType.Skill_cCalled) then
        return {}
    end
    -- 持续施法
    if con.isSpell and con.isSpell == 1 then
       return self:handleSpellTimeLine(con,supplementaryData)
    end
    -- 蓄力大招
    if con.isSing and con.isSing == 1 then
        if self._skillPosition == Enum_Battle.SkillTag.Skill_1 then
            return self:handleSingTimeLine(con,supplementaryData)
        else
            Logger.error("不是 大招 所以 蓄力与否 不做处理  tag == ",self._skillTag)
        end
    end
    -- 普通大招
    return self:handleCommonTimeline(con)

end

function SkillData:handleSingTimeLine(con,supplementaryData)
    local tmp = {}
    tmp.type = Enum_Battle.TimeLineGroupType.BreakFixFrame
    local supplementaryTimeMap = supplementaryData.timeLineMap[1]
    for frameCount, frameInfo in pairs(supplementaryTimeMap) do
        for _, frameData in pairs(frameInfo) do
            tmp[frameCount] = tmp[frameCount] or {}
            table.insert(tmp[frameCount],frameData)
        end
    end
    if self._skillPosition == Enum_Battle.SkillTag.Skill_1 then
        tmp[-1] = tmp[-1] or {}
        table.insert(tmp[-1],SkillUtils:newSkillBlackoutStartFrameEvent(con.param,con.movParam))
    end
    self:handleArtTimeLine(tmp,con)

    self:handleSoundTimeLine(tmp,con)

    self:handleCastTimeLine(tmp,con)

    self:handleEventTimeLine(tmp,con)

    self:handleBreakFrame(tmp,con)


end

function SkillData:handleSpellTimeLine(con,supplementaryData)
    local tmp = {}
    tmp.type = Enum_Battle.TimeLineGroupType.FixFrame

    local supplementaryTimeMap = supplementaryData.timeLineMap[1]
    for frameCount, frameInfo in pairs(supplementaryTimeMap) do
        for _, frameData in pairs(frameInfo) do
            tmp[frameCount] = tmp[frameCount] or {}
            table.insert(tmp[frameCount],frameData)
        end
    end

    if self._skillPosition == Enum_Battle.SkillTag.Skill_1 then
        tmp[-1] = tmp[-1] or {}
        table.insert(tmp[-1],SkillUtils:newSkillBlackoutStartFrameEvent(con.param,con.movParam))
    end

    self:handleArtTimeLine(tmp,con)

    self:handleSoundTimeLine(tmp,con)

    self:handleCastTimeLine(tmp,con)

    self:handleEventTimeLine(tmp,con)

    if not (con.isSpell and con.isSpell == 1 and con.spellUltra and con.spellUltra == 1) then
        self:handleBreakFrame(tmp,con)
    end
end

function SkillData:handleCommonTimeline(con)
    local tmp = {}

    tmp.type = Enum_Battle.TimeLineGroupType.FixFrame

    tmp[-1] = { SkillUtils:newAnimationFrameEventByPos(1,con.position)}

    if self._skillPosition == Enum_Battle.SkillTag.Skill_1 then
       table.insert(tmp[-1],SkillUtils:newSkillBlackoutStartFrameEvent(con.param,con.movParam))
    end

    self:handleArtTimeLine(tmp,con)

    self:handleSoundTimeLine(tmp,con)

    self:handleCastTimeLine(tmp,con)

    self:handleEventTimeLine(tmp,con)

    self:handleBreakFrame(tmp,con)


    return {tmp}
end

function SkillData:handleArtTimeLine(tmp,con)
    local artTimeline = con.artTimeline or {}
    for i, v in ipairs(artTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],SkillUtils:newArtFrameEvent(frame,v[2],v[3]))
    end
end

function SkillData:handleSoundTimeLine(tmp,con)
    local soundTimeline = con.soundTimeline or {}
    for i, v in ipairs(soundTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],SkillUtils:newSoundFrameEvent(frame,v[2]))
    end
end

function SkillData:handleCastTimeLine(tmp,con)
    local castTimeline = con.castTimeline or {}
    for i, v in ipairs(castTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],SkillUtils:newCastFrameEvent(frame,v[2]))
    end
end

function SkillData:handleEventTimeLine(tmp,con)
    local eventTimeline = con.eventTimeline or {}
    for i, v in ipairs(eventTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],SkillUtils:newEventFrameEvent(frame,v,con.param,con.movParam))
    end
end

function SkillData:handleBreakFrame(tmp,con)
    if con.position == Enum_Battle.SkillTag.Skill_1 then
        return
    end
         -- 前摇不可被打算
    if (not (con.canBreak1 and con.canBreak1 == 1))  then
        tmp[1] = tmp[1] or {}
        table.insert(tmp[1],SkillUtils:newUnBreakOffStartFrameEvent(1,con.position))
    else
        if con.position ~= Enum_Battle.SkillTag.Skill_5 then
            tmp[con.frontHalf] = tmp[con.frontHalf] or {}
            table.insert(tmp[con.frontHalf],SkillUtils:newUnBreakOffStartFrameEvent(con.frontHalf,con.position))
        end
    end
    -- 后摇不可以被打断
    if (not (con.canBreak2 and con.canBreak2 == 1)) then
        tmp[con.endFrame] = tmp[con.endFrame] or {}
        table.insert(tmp[con.endFrame],SkillUtils:newUnBreakOffEndFrameEvent(con.endFrame,con.position))
    else
        if con.position ~= Enum_Battle.SkillTag.Skill_5 then
            tmp[con.behindHalf] = tmp[con.behindHalf] or {}
            table.insert(tmp[con.behindHalf],SkillUtils:newUnBreakOffEndFrameEvent(con.behindHalf,con.position))
        end
    end
end

return SkillData