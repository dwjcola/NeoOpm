---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2022/1/6 20:52
---@class SkillData
local SkillData = SimpleClassUtil:class()

function SkillData:initialize(con)
    self:initParams(con)
end

function SkillData:initParams(con)
    -- 大招 还是 普攻 还是 普通技能
    self._skillType = con.position
    -- 数值表数值
    self._skillCon = con
    -- 上次释放时间
    self._skill_time_play = 0

    -- 是否被动
    self._isPassive = con.type == Enum_Battle.SkillType.Skill_passive

    -------------------------------

    -- 技能释放的消耗
    self._skillCost = con.cost or nil
    -- 释放释放得条件 怒气 -- 目前是约定得只有大招才需要怒气 而且是 常量 1000
    self._skill_need_power = con.type == Enum_Battle.SkillType.Skill_super and BattleConstant.SkillLaunchEnergy or 0
    -- 技能释放得特殊条件
    self._condition = con.condition or nil
    -- 技能释放得范围判断类型条件
    self._skill_launch_ranger_type = con.rangeType or Enum_Battle.SkillLaunchRangeType.Passive
    --技能释放的范围
    self._skill_launch_ranger_params = con.ranger
    --技能释放的目标类型
    self._skill_launch_target_type = con.targetType
    -- 普攻攻击距离
    self._skill_r = con.type == Enum_Battle.SkillType.Skill_a and con.range[1] or 0
    -- 技能cd
    self._skill_time_cd = con.cd2 or 0
    -- 初始前置技能cd
    self._skill_time_initCd = con.cd1 or 0
    -- Gcd
    self._skill_gCd = con.gcd or 0
    -- 释放时增加的怒气
    self._skill_add_power = con.addPower or 0
    -- 是否是蓄力
    self._isStoreUp = (con.isSing and con.isSing == 1) or false
    -- 是否持续施法
    self._isSpell =  (con.isSpell and con.isSpell == 1) or false
    -- 持续施法中满怒是否立刻放大
    self._spellUltra = (con.spellUltra and con.spellUltra == 1) or false
    -- 是否无视异常状态
    self._unstoppable = (con.unstoppable and con.unstoppable == 1) or false


    -- 前摇结束帧
    self._frontHalfFrame = con.frontHalf or 0
    -- 后摇开始帧
    self._behindHalfFrame = con.behindHalf or 0
    -- 前摇是否可以被打断
    self._canBreak_forward = con.canBreak1 and con.canBreak1 == 1 or false
    -- 后摇是否可以被打断
    self._canBreak_back = con.canBreak2 and con.canBreak2 == 1 or false
    -- 结束帧
    self._endFrame = con.endFrame or 0
    -- 特殊参数
    self._specialParam = con.param
    -- 帧事件map
    self._timeLineMap = self:handleTimeLineMap(con)

    ---- 美术timeline
    --self._artTimeline = self:handleArtTimeLine(con.artTimeline)
    ---- 声音timeline
    --self._soundTimeline = self:handleSoundTimeLine(con.soundTimeline)
    ---- 配音timeline
    --self._castTimeline = self:handleCastTimeLine(con.castTimeline)
    ---- 配音timeline
    --self._eventTimeline = self:handleEventTimeLine(con.eventTimeline)

end

function SkillData:handleTimeLineMap(con)
    if con.type == Enum_Battle.SkillType.Skill_special then
        return con.timeLineMap
    end

    if con.isSpell and con.isSpell == 1 then
       return {}
    end
    if con.isSing and con.isSing == 1 then
        return {}
    end

    return self:handleCommonTimeline(con)

end

function SkillData:handleCommonTimeline(con)
    local tmp = {}

    tmp.type = Enum_Battle.TimeLineGroupType.FixFrame

    tmp[-1] = { self:newAnimationFrameEvent(0,BattleUtils:getAnimationNameByPos(con.position)) }
    local artTimeline = con.artTimeline or {}
    for i, v in ipairs(artTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],self:newArtFrameEvent(frame,v[2],v[3]))
    end
    local soundTimeline = con.soundTimeline or {}
    for i, v in ipairs(soundTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],self:newSoundFrameEvent(frame,v[2]))
    end
    local castTimeline = con.castTimeline or {}
    for i, v in ipairs(castTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],self:newCastFrameEvent(frame,v[2]))
    end
    local eventTimeline = con.eventTimeline or {}
    for i, v in ipairs(eventTimeline) do
        local frame = v[1]
        frame = frame == 0 and -1 or frame
        if tmp[frame] == nil then
            tmp[frame] = {}
        end
        table.insert(tmp[frame],self:newEventFrameEvent(frame,v,con.param))
    end

    return {tmp}
end

function SkillData:newAnimationFrameEvent(frame,aniName)
    return {
        type = Enum_Battle.TimeLineEventType.Animation,
        aniName = aniName,
        frame = frame,
    }
end

function SkillData:newArtFrameEvent(frame,parma_1,parma_2)
    return {
        type = Enum_Battle.TimeLineEventType.Art,
        frame = frame,
        srcName = parma_1,
        pos = parma_2,
    }
end

function SkillData:newSoundFrameEvent(frame,parma_1)
    return {
        type = Enum_Battle.TimeLineEventType.Sound,
        frame = frame,
        srcName = parma_1,
    }
end

function SkillData:newCastFrameEvent(frame,parma_1)
    return {
        type = Enum_Battle.TimeLineEventType.Cast,
        frame = frame,
        srcName = parma_1,
    }
end

function SkillData:newEventFrameEvent(frame,frameData,specialParam)
    return {
        type = frameData[2],
        frame = frame,
        eventTag = frameData[3],
        specialParam = specialParam,
    }
end

return SkillData