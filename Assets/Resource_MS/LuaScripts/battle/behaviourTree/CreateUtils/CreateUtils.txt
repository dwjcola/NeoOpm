---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2021/12/9 17:14
---@class CreateUtils
local CreateUtils = {}

function CreateUtils:isLeafNode(type)
    --local node = btApplyMap:getClass(nodeValue._identificationName)
    --if node == nil then
    --    BattleLog.error("节点实例化失败 ！！！  nodeValue == ",nodeValue)
    --    return nil
    --end
    return type == Enum_BT.Node_Type.Action or type == Enum_BT.Node_Type.Condition
end

---@return NodeBase
function CreateUtils:getNodeByType(type,entityId)
    local node = nil
    if type == Enum_BT.Node_Type.Select then
        node = NodeSelect:new()
    elseif type == Enum_BT.Node_Type.Sequence then
        node = NodeSequence:new()
    elseif type == Enum_BT.Node_Type.Random then
        node = NodeRandomSelect:new()
    elseif type == Enum_BT.Node_Type.Random_Sequence then
        node = NodeRandomSequence:new()
    elseif type == Enum_BT.Node_Type.Random_Priority then
        node = NodeRandomPriority:new()
    elseif type == Enum_BT.Node_Type.Parallel then
        node = NodeParallel:new()
    elseif type == Enum_BT.Node_Type.Parallel_Select then
        node = NodeParallelSelect:new()
    elseif type == Enum_BT.Node_Type.Parallel_All then
        node = NodeParallelAll:new()
    elseif type == Enum_BT.Node_Type.IF_Judge then
        node = NodeIfJudge:new()
    elseif type == Enum_BT.Node_Type.Decorator_Inverter then
        node = NodeDecoratorInverter:new()
    elseif type == Enum_BT.Node_Type.Decorator_Repeat then
        node = NodeDecoratorRepeat:new()
    elseif type == Enum_BT.Node_Type.Decorator_Return_Fail then
        node = NodeDecoratorReturnFail:new()
    elseif type == Enum_BT.Node_Type.Decorator_Return_Success then
        node = NodeDecoratorReturnSuccess:new()
    elseif type == Enum_BT.Node_Type.Decorator_Until_Fail then
        node = NodeDecoratorUntilFail:new()
    elseif type == Enum_BT.Node_Type.Decorator_Until_Success then
        node = NodeDecoratorUntilSuccess:new()
    elseif type == Enum_BT.Node_Type.Condition then
        node = NodeCondition:new()
    elseif type == Enum_BT.Node_Type.ConditionGroup then
        node = NodeConditionGroup:new()
    elseif type == Enum_BT.Node_Type.Action then
        node = NodeAction:new()
    elseif type == Enum_BT.Node_Type.Sub_Tree then
        node = NodeSubTree:new()
    else
        BattleLog.error("未处理类型！！！！  ： " , tostring(type))
    end
    node:setEntityId(entityId)
    return node
end
---@return ICondition
function CreateUtils:getICondition(conName,data)
    ---@type ICondition
    local con = btApplyMap:getClass(conName)
    con:initData(data)
    return con
end
---@return IAction
function CreateUtils:getIAction(conName,data)
    ---@type IAction
    local action = btApplyMap:getClass(conName)
    action:initData(data)
    return action
end
---@param blackboard BlackBoard_BattleBase
---@param skillData SkillData
function CreateUtils:getSkillFireSpecialCon(blackboard, skillData)
    local condition = skillData._condition
    local type = condition[1]
    if type == Enum_Battle.SkillFireSpecialCondition.AroundNoEnemy then
        return  self:getICondition("bt_con_aroundNoEnemy",skillData)
    else
        BattleLog.error("特殊技能判断类型 未处理 ： ",type)
    end
end
---@param blackboard BlackBoard_BattleBase
---@param skillData SkillData
function CreateUtils:getSkillFireRangerCon(blackboard, skillData)
    local rangeType = skillData._skill_launch_ranger_type
    if rangeType == Enum_Battle.SkillLaunchRangeType.Passive or rangeType == Enum_Battle.SkillLaunchRangeType.JumpRange then
        return nil
    elseif rangeType == Enum_Battle.SkillLaunchRangeType.Roundness then
        return self:getICondition("bt_con_around_circle",skillData)
    elseif rangeType == Enum_Battle.SkillLaunchRangeType.FullScreen then
        return self:getICondition("bt_con_fullScreen",skillData)
    elseif rangeType == Enum_Battle.SkillLaunchRangeType.Rectangle_forward then
        return self:getICondition("bt_con_rectangle_forward",skillData)
    elseif rangeType == Enum_Battle.SkillLaunchRangeType.Sector_forward then
        return self:getICondition("bt_con_sector_forward",skillData)
    else
        BattleLog.error("技能范围判断类型 未处理 ： ",rangeType)
    end
end

---@return BlackBoard
function CreateUtils:createBlackBoard(heroId,sceneData,cultivateData)
    local blackBoard = BlackBoard:new()
    blackBoard._heroId = heroId
    blackBoard._sceneData = sceneData
    --blackBoard._index = sceneData.index
    --blackBoard._position = sceneData.position
    --blackBoard._skeleton_head = sceneData.skeleton_head
    --blackBoard._skeleton_bosom = sceneData.skeleton_bosom
    --blackBoard._skeleton_root = sceneData.skeleton_root

    blackBoard._cultivateData = cultivateData
    return blackBoard
end

function CreateUtils:createTree(blackboard)
    ---@type NodeIfJudge
    local root = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000001")
    -------------------------------------------------------------------------------
          ---@type NodeCondition  判断是否活着
          local node_1 = self:getNodeByType(Enum_BT.Node_Type.Condition,"0000002")
          node_1:setICondition(self:getICondition("bt_con_compare_base",{ _compareType = Enum_BT.CompareType.BT_GreaterThan, _key = "_hp", _compareTargetValue = 0, }))
    root:addNode(node_1)
    ---------------------------------------------------------------------------------
    root:addNode(self:createLiveTree(blackboard))
    ---------------------------------------------------------------------------------
    root:addNode(self:createDiedTree(blackboard))
    --------------
    return  root
end

--- 死亡树
function CreateUtils:createDiedTree(blackboard)
    ---@type NodeAction 死亡 行为
    local node = self:getNodeByType(Enum_BT.Node_Type.Action,"0000006")
    node:setIAction(self:getIAction("bt_ac_died"))
    return node
end

function CreateUtils:createLiveTree(blackboard)
    ---@type NodeSequence
    local node = self:getNodeByType(Enum_BT.Node_Type.Sequence,"createLiveTree_001")
    node:addNode(self:createInitSkillCdTree(blackboard))
    node:addNode(self:createLoopSkillsTree(blackboard))
    return node
end
---初始化技能Cd
function CreateUtils:createInitSkillCdTree(blackboard)
    ---@type NodeAction
    local node = self:getNodeByType(Enum_BT.Node_Type.Action,"createInitSkillCdTree_0001")
    node:setIAction(self:getIAction("bt_ac_initSkillCd"))
    return node
end

--- 技能树
function CreateUtils:createLoopSkillsTree(blackboard)
    ---@type NodeDecoratorRepeat 一直 判断技能 树
    local node_2 = self:getNodeByType(Enum_BT.Node_Type.Decorator_Repeat,"0000003")
    node_2:setRepeatCount(-1)
          ---@type NodeParallelAll
          local node_2_1 = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000004")
              -- 1.先添加 被动技能
             --local  passiveNode = self:createPassiveTree(blackboard)
             --if passiveNode then
             --    node_2_1:addNode(passiveNode)
             --end
             -- 2. 仇恨值列表刷新树
          node_2_1:addNode(self:createHostilityValueTree(blackboard))
             -- 3.技能树
              ---@type NodeParallelAll 技能 行为
              local node_2_1_2 = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000005")
              node_2_1_2:addNode(self:createBigSkillJudgeTree(blackboard))
              node_2_1_2:addNode(self:createBigSkillTree(blackboard))
              node_2_1_2:addNode(self:createSkillMoveTree(blackboard))
          node_2_1:addNode(node_2_1_2)
          node_2_1:addNode(self:getGcdTree(blackboard))
    node_2:addNode(node_2_1)
    return node_2
end
--- GCD计时树
---@param blackboard BlackBoard_BattleBase
function CreateUtils:getGcdTree(blackboard)
    ---@type NodeIfJudge
    local node = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"GcdTree_1")

    ---@type NodeCondition
    local node_1 = self:getNodeByType(Enum_BT.Node_Type.Condition)
    node_1:setICondition(self:getICondition("bt_con_compare_base",
            { _compareType = Enum_BT.CompareType.BT_GreaterThan, _key = "_gcd", _compareTargetValue = 0}))
    node:addNode(node_1)

    ---@type NodeAction
    local node_2 = self:getNodeByType(Enum_BT.Node_Type.Action)
    node_2:setIAction(self:getIAction("bt_ac_count_down"))
    node:addNode(node_2) --
    return node
end
--- 被动树
---@param blackboard BlackBoard_BattleBase
function CreateUtils:createPassiveTree(blackboard)
    ---@type bt_ac_passive
    local node = nil
    if blackboard and blackboard._skillData then
        for i, v in pairs(blackboard._skillData) do
            if v and v._isPassive then
                if node == nil then
                    node = btApplyMap:getClass("bt_ac_passive")
                    node:addPassive(v)
                end
            end
        end
    end
    return node
end
--- 仇恨值列表
function CreateUtils:createHostilityValueTree(blackboard)
    -- 仇恨值 目标计算
    local node_2_1_3 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000005_1")
          ---@type NodeConditionGroup
          local node_2_1_3_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"0000005_2")
                local con_2_1_3_1_1 = btApplyMap:getClass("bt_con_enmityTargetCheck")
                local con_2_1_3_1_2 = btApplyMap:getClass("bt_con_enmityCd")
                con_2_1_3_1_2:initData({cdTime = 10000})
                local con_2_1_3_1_3 = btApplyMap:getClass("bt_onReceive")
                con_2_1_3_1_3:initData({eventId = EventType.Event_Battle_Died})
                local con_2_1_3_1_4 = btApplyMap:getClass("bt_onBeAttack_isNotEnmity")
                con_2_1_3_1_4:initData()
          node_2_1_3_1:setIConditionS({con_2_1_3_1_1,con_2_1_3_1_2,con_2_1_3_1_3,con_2_1_3_1_4},Enum_BT.Condition_Relation.BT_OR)
    node_2_1_3:addNode(node_2_1_3_1)
          ---@type NodeAction
          local node_2_1_3_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000005_3")
                local ac_2_1_3_2_1 = btApplyMap:getClass("bt_ac_refreshEnmityList")
          node_2_1_3_2:setIAction(ac_2_1_3_2_1)
    node_2_1_3:addNode(node_2_1_3_2)
    return node_2_1_3
end
---@param blackboard BlackBoard_BattleBase
function CreateUtils:createBigSkillJudgeTree(blackboard)
    ---@type SkillData
    local skillData = blackboard._skillData[Enum_Battle.SkillTag.Skill_1]
    ---@type NodeIfJudge 判断是否满足 大招释放条件
    local node = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000007")

    node:addNode(self:baseSkillCondition(blackboard,skillData,false))

    node:addNode(self:bigSkillCondition_to_true(blackboard,skillData))

    node:addNode(self:bigSkillCondition_to_false(blackboard,skillData))

    return node
end
---@param blackboard BlackBoard_BattleBase
---@param skillData SkillData
function CreateUtils:baseSkillCondition(blackboard,skillData,isInfluenced_gcd)
    ---@type NodeConditionGroup
    local node = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,tostring(skillData._skillTag))
    local tmp = {}

    table.insert(tmp, self:getICondition("bt_con_compare_base",
            { _compareType = Enum_BT.CompareType.BT_GreaterThanEqual, _key = "_anger",
              _compareTargetValue = skillData._skill_need_power or 0 }))

    table.insert(tmp,self:getICondition("bt_con_astrict",
            { skillTag = Enum_Battle.SkillTag.Skill_1, isDefy = skillData._unstoppable, }))

    table.insert(tmp, self:getICondition("bt_con_compare_base",
            { _compareType = Enum_BT.CompareType.Bt_Equal, _key = "_smallSkillContBeBreak", _compareTargetValue = false, }))

    table.insert(tmp, self:getICondition("bt_con_cd", skillData))


    if isInfluenced_gcd then
        table.insert(tmp, self:getICondition("bt_con_compare_base",
                { _compareType = Enum_BT.CompareType.BT_LessThanEqual, _key = "_gcd", _compareTargetValue = 0, }))
    end
    if skillData and skillData._condition then
        local specialConNode = self:getSkillFireSpecialCon(blackboard, skillData)
        if specialConNode then
            table.insert(tmp,specialConNode)
        end
    end
    if skillData and skillData._skill_launch_ranger_type then
        local rangerConNode = self:getSkillFireRangerCon(blackboard, skillData)
        if rangerConNode then
            table.insert(tmp,rangerConNode)
        end
    end
    node:setIConditionS(tmp,Enum_BT.Condition_Relation.BT_AND)
    return node
end

function CreateUtils:bigSkillCondition_to_true(blackboard,skillData)
    ---@type NodeSequence
    local node = self:getNodeByType(Enum_BT.Node_Type.Sequence,"0000009")
      ---@type NodeAction
      local node_1 = self:getNodeByType(Enum_BT.Node_Type.Action),"0000010"
      node_1:setIAction(self:getIAction("bt_ac_setValue",{key = "_bigSkillReady",value = true}))
      ---@type NodeAction
      local node_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000011")
      node_2:setIAction(self:getIAction("bt_ac_sendMag",{eventKey = EventType.Event_BigSkillCanRelease}))

    node:addNode(node_1)
    node:addNode(node_2)
    return node
end

function CreateUtils:bigSkillCondition_to_false(blackboard,skillData)
    ---@type NodeSequence
    local node = self:getNodeByType(Enum_BT.Node_Type.Sequence,"0000012")
       ---@type NodeAction
       local node_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000013")
       node_1:setIAction(self:getIAction("bt_ac_setValue",{key = "_bigSkillReady",value = false}))

       ---@type NodeAction
       local node_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000014")
       node_2:setIAction(self:getIAction("bt_ac_sendMag",{eventKey = EventType.Event_BigSkillCannotRelease}))
    node:addNode(node_1)
    node:addNode(node_2)
    return node
end

function CreateUtils:createSkillMoveTree(blackBoard)
   ---@type NodeIfJudge
   local node = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"createSkillMove_Tree 001")
      ---@type NodeConditionGroup
      local node_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"createSkillMove_Tree 002")
        -----@type ICondition
        local condition_1_1 = btApplyMap:getClass("bt_con_compare_base")
        condition_1_1:initData({ _compareType = Enum_BT.CompareType.BT_UnequalTo, _key = "_skill_moveSpeed", _compareTargetValue = 0,})
        -----@type ICondition
        local condition_1_2 = btApplyMap:getClass("bt_con_compare_base")
        condition_1_2:initData({ _compareType = Enum_BT.CompareType.BT_GreaterThan, _key = "_skill_moveFrame", _compareTargetValue = 0,})
      node_1:setIConditionS({condition_1_1,condition_1_2},Enum_BT.Condition_Relation.BT_AND)
      ---@type NodeAction
      local node_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"createSkillMove_Tree 003")
      node_2:setIAction(self:getIAction("bt_ac_skill_move"))
    node:addNode(node_1)
    node:addNode(node_2)
    return node
end

function CreateUtils:createBigSkillTree(blackBoard)
    ---@type NodeIfJudge
    local node = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000015")
          ---@type NodeConditionGroup
          local node_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"0000016")
                -----@type ICondition
                local condition_1_1 = btApplyMap:getClass("bt_con_compare_base")
                condition_1_1:initData({ _compareType = Enum_BT.CompareType.Bt_Equal, _key = "_bigSkillReady", _compareTargetValue = true, })
                -----@type ICondition
                local condition_1_2 = btApplyMap:getClass("bt_con_compare_base")
                condition_1_2:initData({ _compareType = Enum_BT.CompareType.Bt_Equal, _key = "_isKeyDownBigSkill", _compareTargetValue = true,  })

          local tmp_1 = {condition_1_1,condition_1_2}
          node_1:setIConditionS(tmp_1,Enum_BT.Condition_Relation.BT_AND)
    node:addNode(node_1)

    node:addNode(self:createSkill(blackBoard,Enum_Battle.SkillTag.Skill_1))

    node:addNode(self:createSmallSkillTree(blackBoard))
    return node
end
--- 技能释放树
function CreateUtils:createSkill(blackBoard,skillTag)
    ---@type NodeSequence
    local node = self:getNodeByType(Enum_BT.Node_Type.Sequence,"create_SkillSuper_001")

    node:addNode(self:createSetPlaySkill(skillTag))
    node:addNode(self:createSetSkillPlayTime())
    node:addNode(self:createStopFindWay())
    ---@type SkillData
    local skillData = blackBoard._skillData[skillTag]

    self:createSetGcd(node,skillData)

    local timeMap = skillData._timeLineMap or {}

    for i, v in ipairs(timeMap) do
        ---@type NodeAction
        local node_ac_playSkill = self:getNodeByType(Enum_BT.Node_Type.Action,"create_SkillSuper_003")
        if v.type == Enum_Battle.TimeLineGroupType.FixFrame then
            node_ac_playSkill:setIAction(self:getIAction("bt_ac_playTimeLine",
                    {skillData = skillData ,timeLineInfo = v}))

        elseif v.type == Enum_Battle.TimeLineGroupType.BreakFixFrame then
            -- todo 等待开发
        else
            -- todo 等待开发
        end
        node:addNode(node_ac_playSkill)
    end
    node:addNode(self:createSetAnger(skillData._skill_add_anger))
    self:setSkillPlayCost(node,skillData)
    node:addNode(self:createSetPlaySkill(nil))
    return node
end
-- 设置 gcd
function CreateUtils:createSetGcd(rootNode,skillData)
    if skillData._skill_gCd and skillData._skill_gCd > 0 then
        ---@type NodeAction
        local node = self:getNodeByType(Enum_BT.Node_Type.Action,"create_SetGcd")
        node:setIAction(self:getIAction("bt_ac_setValue",{key = "_gcd",value = skillData._skill_gCd}))
        rootNode:addNode(node)
    end
end
-- 技能释放得 消耗 gcd
---@param skillData SkillData
function CreateUtils:setSkillPlayCost(rootNode,skillData)
    if skillData._skillCost and skillData._skillCost[1] and skillData._skillCost[2]  then
        if skillData._skillCost[1] == Enum_Battle.SkillCostType.Anger then
            ---@type NodeAction
            local node = self:getNodeByType(Enum_BT.Node_Type.Action,"set_SkillPlayCost_anger")
            node:setIAction(self:getIAction("bt_ac_setValue",{key = "_anger",value = 0}))
            rootNode:addNode(node)
        end
    end
end
--设置正在释放得技能 是哪个
function CreateUtils:createSetPlaySkill(skillTag)
    ---@type NodeAction
    local node = self:getNodeByType(Enum_BT.Node_Type.Action,"create_SetPlaySkill")
    node:setIAction(self:getIAction("bt_ac_setValue",{key = "_playSkillTag",value = skillTag}))
    return node
end

-- 设置怒气
function CreateUtils:createSetAnger(anger)
    ---@type NodeAction
    local node = self:getNodeByType(Enum_BT.Node_Type.Action,"createSetAnger")
    node:setIAction(self:getIAction("bt_ac_setValue",{key = "_anger",value = anger or 0,setValueType = Enum_BT.SetValueType.BT_AddEqual}))
    return node
end

function CreateUtils:createSetSkillPlayTime(skillTag)
    ---@type NodeAction
    local node_ac_skillPlayTime = self:getNodeByType(Enum_BT.Node_Type.Action,"create_SkillSuper_002")
    node_ac_skillPlayTime:setIAction(self:getIAction("bt_ac_setSkillPlayTime",skillTag))
    return node_ac_skillPlayTime
end

--- 停止寻路
function CreateUtils:createStopFindWay()
    ---@type NodeAction
    local node = self:getNodeByType(Enum_BT.Node_Type.Action,"createStopFindWay001")
    node:setIAction(self:getIAction("bt_ac_setValue",{key = "_find_target_pos",value = nil}))
    return node
end


function CreateUtils:createSmallSkillTree(blackboard)
    ---@type NodeParallelAll
    local node = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000018")

    --node:addNode(self:createSelectSmallSkillTree())

    node:addNode(self:createTreeExceptSmallSkill(blackboard))
    return node
end

function CreateUtils:createSelectSmallSkillTree()
    -----@type NodeSelect
    local node_1 = self:getNodeByType(Enum_BT.Node_Type.Select,"0000019")
          ---@type NodeIfJudge
          local node_1_1 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000020")
                 ---@type NodeConditionGroup
                 local node_1_1_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"0000021")
                       -----@type bt_con_astrict
                       local condition_1_1_1_0 = btApplyMap:getClass("bt_con_astrict")
                       condition_1_1_1_0:initData({ skillTag = Enum_Battle.SkillTag.Skill_2, isDefy = false, })
                       -----@type bt_con_cd
                       local condition_1_1_1_1 = btApplyMap:getClass("bt_con_cd")
                       condition_1_1_1_1:initData({ skillTag = Enum_Battle.SkillTag.Skill_2, cdTime = 5000 })
                       -----@type ICondition
                       local condition_1_1_1_2 = btApplyMap:getClass("bt_con_monomer")
                       condition_1_1_1_2:initData({ skillTag = Enum_Battle.SkillTag.Skill_2, skillDistance = 100  })
                local tmp_1 = {condition_1_1_1_0,condition_1_1_1_1,condition_1_1_1_2}
                node_1_1_1:setIConditionS(tmp_1,Enum_BT.Condition_Relation.BT_AND)
                --- @type NodeSequence
                local node_1_1_2 = self:getNodeByType(Enum_BT.Node_Type.Sequence,"0000022")
                      ---@type NodeAction
                      local node_1_1_2_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000023")
                            local ac_1_1_2_1 = btApplyMap:getClass("bt_ac_setValue")
                             ac_1_1_2_1:initData({key = "_smallSkillIng",value = true})
                      node_1_1_2_1:setIAction(ac_1_1_2_1)
                node_1_1_2:addNode(node_1_1_2_1)
                      ---@type NodeAction
                     local node_1_1_2_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000024")
                           local ac_1_1_2_2 = btApplyMap:getClass("bt_ac_playSkill")
                           ac_1_1_2_2:initData({})
                     node_1_1_2_2:setIAction(ac_1_1_2_2)
                node_1_1_2:addNode(node_1_1_2_1)
          node_1_1:addNode(node_1_1_1)
          node_1_1:addNode(node_1_1_2)
    node_1:addNode(node_1_1)
    return node_1
end

function CreateUtils:createTreeExceptSmallSkill(blackboard)
    ---@type NodeIfJudge 判断是不是 在放 小技能
    local node = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000025")
          ---@type NodeCondition
          local node_1 = self:getNodeByType(Enum_BT.Node_Type.Condition,"0000025_1")
                -----@type bt_con_compare_base
                local condition_1_1 = btApplyMap:getClass("bt_con_compare_base")
                condition_1_1:initData({ _compareType = Enum_BT.CompareType.Bt_Equal, _key = "_smallSkillIng", _compareTargetValue = false, })
          node_1:setICondition(condition_1_1)
    node:addNode(node_1)
          ---@type NodeParallel
          local node_2 = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000025_2")
          node_2:addNode(self:createOptimizeTree())
          node_2:addNode(self:createOrdinarySkillTree(blackboard))
    node:addNode(node_2)
    return node
end

function CreateUtils:createOptimizeTree()
    ---@type NodeParallelAll
   local node = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000026")
    ---@type NodeAction
      local node_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000026_1")
        ---@type bt_ac_check_change_place_r
        local ac_1 = btApplyMap:getClass("bt_ac_check_change_place_r")
      node_1:setIAction(ac_1)
    node:addNode(node_1)
      ---@type NodeIfJudge
       local node_2 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000026_2")
         ---@type NodeConditionGroup
         local node_2_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"0000026_2_1")
            local con_2_1_1 = btApplyMap:getClass("bt_con_compare_base")
                  con_2_1_1:initData({ _compareType = Enum_BT.CompareType.Bt_Equal, _key = "_find_target_pos", _compareTargetValue = nil, })
            local con_2_1_2 = btApplyMap:getClass("bt_con_baseControlled")
            local con_2_1_3 = btApplyMap:getClass("bt_con_isDislocation")

         local tmp_01 = {con_2_1_1,con_2_1_2,con_2_1_3}
         node_2_1:setIConditionS(tmp_01, Enum_BT.Condition_Relation.BT_AND)
       node_2:addNode(node_2_1)
         ---@type NodeParallelAll
         local node_2_2 = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000026_2_2")
               ---@type NodeAction
               local node_2_2_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000026_2_2")
               local ac_2_2_1 = btApplyMap:getClass("bt_ac_malposed_findTarget")
               node_2_2_1:setIAction(ac_2_2_1)
         node_2_2:addNode(node_2_2_1)
                ---@type NodeAction
                local node_2_2_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000026_2_2")
                local ac_2_2_2 = btApplyMap:getClass("bt_ac_malposed_findWay")
                node_2_2_2:setIAction(ac_2_2_2)
         node_2_2:addNode(node_2_2_2)
       node_2:addNode(node_2_2)
    node:addNode(node_2)
    return node
end

function CreateUtils:createOrdinarySkillTree(blackboard)
    ---@type SkillData
    local skillData = blackboard._skillData[Enum_Battle.SkillTag.Skill_5]
    ---@type NodeIfJudge 判断 能不能 释放普攻
    local node_2 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000027")
    node_2:addNode(self:baseSkillCondition(blackboard,skillData,false))
    node_2:addNode(self:createSkill(blackboard,Enum_Battle.SkillTag.Skill_5))
    node_2:addNode(self:createTreeExceptSkillTree())
    return node_2
end

function CreateUtils:createTreeExceptSkillTree()
    ---@type NodeIfJudge 判断 是不是 被限制 行为了 （眩晕，击退，放逐）
    local node_2_3 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000030")
         ---@type NodeConditionGroup
         local node_2_3_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"0000031")
               -----@type bt_con_astrict
               local condition_2_3_1_1 = btApplyMap:getClass("bt_con_baseControlled")
         node_2_3_1:setIConditionS({condition_2_3_1_1},Enum_BT.Condition_Relation.BT_AND)
    node_2_3:addNode(node_2_3_1)
         ---@type NodeIfJudge 判断 有没有 寻路 目标
         local node_2_3_3_2 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000033_2")
               ---@type NodeConditionGroup
               local node_2_3_3_2_1 = self:getNodeByType(Enum_BT.Node_Type.ConditionGroup,"0000033_2_1")
                     ---@type bt_con_isHadEnemyTarget
                     local condition_2_3_3_1_1 = btApplyMap:getClass("bt_con_isHadEnemyTarget")
               node_2_3_3_2_1:setIConditionS({condition_2_3_3_1_1}, Enum_BT.Condition_Relation.BT_AND)
         node_2_3_3_2:addNode(node_2_3_3_2_1)
         node_2_3_3_2:addNode(self:createFindWayTree())
         node_2_3_3_2:addNode(self:getAwaitTree())
    node_2_3:addNode(node_2_3_3_2)
         local node_2_3_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000032")
               local action_2_3_2 = btApplyMap:getClass("bt_ac_controlled")
         node_2_3_2:setIAction(action_2_3_2)
    node_2_3:addNode(node_2_3_2)
    return node_2_3
end

function CreateUtils:createFindWayTree()
    ---@type NodeParallelAll
    local node = self:getNodeByType(Enum_BT.Node_Type.Parallel_All,"0000035")
         ---@type NodeAction
          local node_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000035_1")
               ---@type bt_ac_switchAnima
               local bt_ac_switchAnima = btApplyMap:getClass("bt_ac_find_target")
          node_1:setIAction(bt_ac_switchAnima)
    node:addNode(node_1)
           --- @type NodeIfJudge
          local node_2 = self:getNodeByType(Enum_BT.Node_Type.IF_Judge,"0000035_2")
                ---@type NodeCondition
                local node_2_1 = self:getNodeByType(Enum_BT.Node_Type.Condition,"0000035_3")
                      ---@type bt_con_compare_base
                      local con_2_1_1 = btApplyMap:getClass("bt_con_compare_base")
                            con_2_1_1:initData({ _compareType = Enum_BT.CompareType.Bt_Equal, _key = "_find_target_pos", _compareTargetValue = nil, })
                node_2_1:setICondition(con_2_1_1)
          node_2:addNode(node_2_1)
          node_2:addNode(self:getAwaitTree())
                local node_2_3 =  self:getNodeByType(Enum_BT.Node_Type.Sequence,"0000035_5")
                     ---@type NodeAction
                     local node_2_3_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000035_6")
                           ---@type bt_ac_switchAnima
                           local ac_2_3_1_1 = btApplyMap:getClass("bt_ac_switchAnima")
                           ac_2_3_1_1:initData({aniName = Enum_Battle.AniState.run,isReset = false,speed = 1})
                     node_2_3_1:setIAction(ac_2_3_1_1)
                node_2_3:addNode(node_2_3_1)
                      ---@type NodeAction
                      local node_2_3_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000035_7")
                            ---@type bt_ac_way_finding
                            local action_2_3_2_1 = btApplyMap:getClass("bt_ac_way_finding")
                            action_2_3_2_1:initData({ })
                       node_2_3_2:setIAction(action_2_3_2_1)
                node_2_3:addNode(node_2_3_2)
          node_2:addNode(node_2_3)
    node:addNode(node_2)
    return node
end


function CreateUtils:getAwaitTree()
    ---@type NodeSequence
    local node =  self:getNodeByType(Enum_BT.Node_Type.Sequence,"await_1")
          ---@type NodeAction
          local node_1 = self:getNodeByType(Enum_BT.Node_Type.Action,"await_1_1")
                ---@type bt_ac_switchAnima
                local ac_1_1 = btApplyMap:getClass("bt_ac_switchAnima")
                ac_1_1:initData({aniName = Enum_Battle.AniState.idle,isReset = true,speed = 1})
          node_1:setIAction(ac_1_1)
    node:addNode(node_1)
    return node

end
--- 转向树
function CreateUtils:getTurnTree()
    ---@type NodeDecoratorReturnSuccess
    local node = self:getNodeByType(Enum_BT.Node_Type.Decorator_Return_Success)

    ---@type NodeSequence
    local node_2_3_3_1 = self:getNodeByType(Enum_BT.Node_Type.Sequence,"0000033_1")
          ---@type NodeCondition
          local node_2_3_3_1_1 = self:getNodeByType(Enum_BT.Node_Type.Condition,"0000033_1_1")
                ---@type bt_con_need_turn
                local condition_2_3_3_1_1 = btApplyMap:getClass("bt_con_need_turn")
          node_2_3_3_1_1:setICondition(condition_2_3_3_1_1)
    node_2_3_3_1:addNode(node_2_3_3_1_1)
          ---@type NodeAction
          local node_2_3_3_1_2 = self:getNodeByType(Enum_BT.Node_Type.Action,"0000033_1_2")
                 ---@type bt_ac_turn
                 local ac_2_3_3_1_2 = btApplyMap:getClass("bt_ac_turn")
          node_2_3_3_1_2:setIAction(ac_2_3_3_1_2)
    node_2_3_3_1:addNode(node_2_3_3_1_2)

    node:addNode(node_2_3_3_1)
    return node
end

return CreateUtils