---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2021/12/13 15:30
---
---@class PVE_Config_Battle_Manager:MiddleClass
local PVE_Config_Battle_Manager = SimpleClassUtil:class()

function PVE_Config_Battle_Manager:initialize(data,isOnlyLogic,battleTeam)

    self._battleData = data or {}
    ---@type boolean 是否只跑逻辑
    self._isOnlyLogic = isOnlyLogic or false

    self._interval = 0.033334


    self._battleTime = 0
    --- 单位 ms
    self._time = 0

    self._loop = 0

    self._maxLoop = 10

    self._ready = false
    ---@type BattleTeam
    self._battleTeam = battleTeam

    self._entityId = 0


    self._list_logicCharacter = {}

    self._list_renderCharacter = {}

    self._list_renderEntity = {}
    -- 战斗倍速
    self._battleSpeed = 2
    -- 计算后的 倍速下 每帧时间间隔
    self._speedInterval = self._interval/self._battleSpeed
end

function PVE_Config_Battle_Manager:getBattleSpeed()
    return self._battleSpeed
end

function PVE_Config_Battle_Manager:getSpeedInterval()
    return self._speedInterval
end

function PVE_Config_Battle_Manager:setBattleSpeed(speed)
    self._battleSpeed = speed or self._battleSpeed
    self._speedInterval = self._interval/self._battleSpeed
end

function PVE_Config_Battle_Manager:start()
    self:initEntity()
    self:formalInit()
    self._ready = true
end

function PVE_Config_Battle_Manager:formalInit()

    self._blackBoard = BlackBoard:new()

    if not self._isOnlyLogic then
        self._world_render = BattleRenderWorld:new()
        self._world_render:init(self._blackBoard,self._battleData,self)
    end
    self._world_logic = BattleLogicWorld:new()
    self._world_logic:init(self._blackBoard,self._battleData,self)
end

function PVE_Config_Battle_Manager:initEntity()
    self:initCharacterEntity()
    self:initSceneEntity()
end

function PVE_Config_Battle_Manager:initCharacterEntity()
    local data = self._battleData

    local func = function(teamData,type)
        for i, v in pairs(teamData.teamMap) do
            local index = i
            local entityId = self:getNewEntityId()

            if self._list_logicCharacter[type] == nil then
                self._list_logicCharacter[type] = {}
            end

            local param = BattleUtils:handlerCharacterData(type,v,teamData,index,entityId)
            self._list_logicCharacter[type][index] = BattleCharacter:new(param,self)
            if not self._isOnlyLogic then

                if self._list_renderCharacter[type] == nil then
                    self._list_renderCharacter[type] = {}
                end
                local  _map_left_role = type == Enum_Battle.Camp.CampSelf and self._battleTeam._map_left_role or self._battleTeam._map_right_role
                local renderCharacter = BattleRenderCharacter:new({
                    go_model = _map_left_role[i].model,
                    index = i,
                    heroId = v.heroId,
                    campType = type,
                    uid = entityId,
                })
                self._list_renderCharacter[type][index] = renderCharacter
            end
        end

    end

    func(data.team_self,Enum_Battle.Camp.CampSelf)

    func(data.team_enemy,Enum_Battle.Camp.CampEnemy)


end

function PVE_Config_Battle_Manager:getNewEntityId()
    self._entityId = self._entityId + 1
    return self._entityId
end

function PVE_Config_Battle_Manager:initSceneEntity()

    local battleSceneEntity = BattleSceneEntity:new(self._battleTeam, self:getNewEntityId())
    table.insert( self._list_renderEntity,battleSceneEntity)
end

function PVE_Config_Battle_Manager:update(dt)
    if self._ready then
        self._time =  self._time + dt * 1000
        if not self:_updateBattle(dt)  then
            self:_updateRender(dt)
        end
    end
end

function PVE_Config_Battle_Manager:_updateBattle(dt)
    local actime = self._battleTime + dt
    self._loop = 0
    -- BattleLog.filter("PVEBattle","_updateBattle",dt,actime)
    while actime >= self._speedInterval and self._loop < self._maxLoop do
        actime = actime - self._speedInterval
        self._loop = self._loop + 1
        --if self:updateLogic(BattleConstant.FrameTime) then
        --    self:_changeToWait()
        --    return
        --end
        self:updateLogic(BattleConstant.FrameTime)
    end
    self._battleTime = actime
    -- 后续优化帧率，先打开所有
    do
        return false
    end

    return self._loop > 0
end

function PVE_Config_Battle_Manager:updateLogic(dt)
    -- CSharpImport.BeginSample("PVEBattle_updateLogic")
    if self._world_logic then
        self._battleResult = self._world_logic:update(dt)
        -- CSharpImport.EndSample()
        return self._battleResult
    end

end


function PVE_Config_Battle_Manager:_updateRender(dt)
    -- todo interpolation 计算是不对的 因为  _speedInterval 实在变化的 不要对 interpolation 进行累加操作
    -- todo 如果帧同步 这里必须修改 但是 此处 不要需要帧同步 不做修改
    local interpolation = self._battleTime / self._speedInterval
    --BattleLog.filter("BattleManager.updateBattle",1000*dt,interpolation)
    self:updateRender(dt * 1000, interpolation)
end

function PVE_Config_Battle_Manager:updateRender(dt, interpolation)
    -- CSharpImport.BeginSample("PVEBattle_updateRender")
    --self:processFrame()
    if self._world_render then
        self._world_render:update(dt, interpolation)
    end

    -- CSharpImport.EndSample()
end


return PVE_Config_Battle_Manager

