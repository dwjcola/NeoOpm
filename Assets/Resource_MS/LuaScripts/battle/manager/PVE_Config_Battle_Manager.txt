---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2021/12/13 15:30
---
---@class PVE_Config_Battle_Manager:MiddleClass
local PVE_Config_Battle_Manager = SimpleClassUtil:class()

function PVE_Config_Battle_Manager:initialize(data,isOnlyLogic,battleTeam,frameControl)

    self._battleData = data or {}
    ---@type boolean 是否只跑逻辑
    self._isOnlyLogic = isOnlyLogic or false

    -- 每帧时间间隔  /s
    self._interval = BattleConstant.FrameTime * 0.001
    ---@type FrameControl
    self._frameControl = frameControl

    self._battleTime = 0
    --- 单位 ms
    self._time = 0

    self._loop = 0

    self._maxLoop = 10

    self._ready = false
    ---@type BattleTeam
    self._battleTeam = battleTeam

    self._entityId = 0


    self._list_logicCharacter = {}

    self._list_renderCharacter = {}

    self._list_renderEntity = {}

    -- todo 设置 是不是自动战斗
    self._automaticBattle = data.isAutoBattle
    -- todo 更具服务器设置  战斗倍速
    self._battleSpeed = data.battleSpeed
    -- 计算后的 倍速下 每帧时间间隔
    self._speedInterval = self._interval/self._battleSpeed

    self._eventListenerList = {}
    self:registerMsg()
end

function PVE_Config_Battle_Manager:getBattleSpeed()
    return self._battleSpeed
end

function PVE_Config_Battle_Manager:getSpeedInterval()
    return self._speedInterval
end

function PVE_Config_Battle_Manager:setBattleSpeed(speed)
    self._battleSpeed = speed or self._battleSpeed
    self._speedInterval = self._interval/self._battleSpeed
end

function PVE_Config_Battle_Manager:start()
    self:initEntity()
    self:formalInit()
    self._ready = true
end

function PVE_Config_Battle_Manager:formalInit()

    self._blackBoard = BlackBoard:new()

    if not self._isOnlyLogic then
        self._world_render = BattleRenderWorld:new()
        self._world_render:init(self._blackBoard,self._battleData,self)
    end
    self._world_logic = BattleLogicWorld:new()
    self._world_logic:init(self._blackBoard,self._battleData,self)
end

function PVE_Config_Battle_Manager:initEntity()
    self:initCharacterEntity()
    self:initSceneEntity()
end

function PVE_Config_Battle_Manager:initCharacterEntity()
    local data = self._battleData

    local func = function(teamData,type)
        for i, v in pairs(teamData.teamMap) do
            local index = i
            local entityId = self:getNewEntityId()

            if self._list_logicCharacter[type] == nil then
                self._list_logicCharacter[type] = {}
            end

            local param = BattleUtils:handlerCharacterData(type,v,teamData,index,entityId)
            self._list_logicCharacter[type][index] = BattleCharacter:new(param,self)
            if not self._isOnlyLogic then

                if self._list_renderCharacter[type] == nil then
                    self._list_renderCharacter[type] = {}
                end
                local  _map_left_role = type == Enum_Battle.Camp.CampSelf and self._battleTeam._map_left_role or self._battleTeam._map_right_role
                local renderCharacter = BattleRenderCharacter:new({
                    go_model = _map_left_role[i].model,
                    index = i,
                    heroId = v.heroId,
                    campType = type,
                    uid = entityId,
                })
                self._list_renderCharacter[type][index] = renderCharacter
            end
        end

    end

    func(data.team_self,Enum_Battle.Camp.CampSelf)

    func(data.team_enemy,Enum_Battle.Camp.CampEnemy)


end

function PVE_Config_Battle_Manager:getNewEntityId()
    self._entityId = self._entityId + 1
    return self._entityId
end

function PVE_Config_Battle_Manager:initSceneEntity()

    local battleSceneEntity = BattleSceneEntity:new(self._battleTeam, self:getNewEntityId())
    table.insert( self._list_renderEntity,battleSceneEntity)
end

function PVE_Config_Battle_Manager:update(dt)
    if self._ready then
        self._time =  self._time + dt * 1000
        if not self:_updateBattle(dt)  then
            self:_updateRender(dt)
        end
    end
end

function PVE_Config_Battle_Manager:_updateBattle(dt)
    local actime = self._battleTime + dt
    self._loop = 0
    -- BattleLog.filter("PVEBattle","_updateBattle",dt,actime)
    while actime >= self._speedInterval and self._loop < self._maxLoop do
        actime = actime - self._speedInterval
        self._loop = self._loop + 1
        --if self:updateLogic(BattleConstant.FrameTime) then
        --    self:_changeToWait()
        --    return
        --end
        self:updateLogic(BattleConstant.FrameTime)
    end
    self._battleTime = actime
    -- 后续优化帧率，先打开所有
    do
        return false
    end

    return self._loop > 0
end

function PVE_Config_Battle_Manager:updateLogic(dt)
    -- CSharpImport.BeginSample("PVEBattle_updateLogic")
    if self._world_logic then
        self._battleResult = self._world_logic:update(dt)
        self._frameControl:update(dt)
        -- CSharpImport.EndSample()
        return self._battleResult
    end

end


function PVE_Config_Battle_Manager:_updateRender(dt)
    -- todo interpolation 计算是不对的 因为  _speedInterval 实在变化的 不要对 interpolation 进行累加操作
    -- todo 如果帧同步 这里必须修改 但是 此处 不要需要帧同步 不做修改
    local interpolation = self._battleTime / self._speedInterval
    --BattleLog.filter("BattleManager.updateBattle",1000*dt,interpolation)
    self:updateRender(dt * 1000, interpolation)
end

function PVE_Config_Battle_Manager:updateRender(dt, interpolation)
    -- CSharpImport.BeginSample("PVEBattle_updateRender")
    --self:processFrame()
    if self._world_render then
        self._world_render:update(dt, interpolation)
    end

    -- CSharpImport.EndSample()
end

function PVE_Config_Battle_Manager:getEventHandleMap()
    return {
        [EventType.Event_Battle_ClientHandle_PauseBattle] = "handleEvent_Battle_ClientHandle_PauseBattle",
        [EventType.Event_Battle_ClientHandle_ClickAutoBattle] = "handleEvent_Battle_ClientHandle_ClickAutoBattle",
        [EventType.Event_Battle_ClientHandle_ClickChangeSpeed] = "handleEvent_Battle_ClientHandle_ClickChangeSpeed",
    }
end

function PVE_Config_Battle_Manager:registerMsg()
    local eventHandleMap = self:getEventHandleMap()
    for i, v in pairs(eventHandleMap) do
        if i and v and self[v] then
            self._eventListenerList[i] = EventManager:AddListener(i,self[v],self)
        end
    end
end

function PVE_Config_Battle_Manager:unRegisterMsg()
    for i, v in pairs(self._eventListenerList) do
        if i and v  then
            EventManager:RemoveListener(i,v)
        end
    end
end
-- todo 调用一哈
function PVE_Config_Battle_Manager:release()
    self:unRegisterMsg()
    if self._world_render and self._world_render.release then
        self._world_render:release()
    end
    if self._world_logic and self._world_logic.release then
        self._world_logic:release()
    end
end

function PVE_Config_Battle_Manager:handleEvent_Battle_ClientHandle_PauseBattle()

end

function PVE_Config_Battle_Manager:handleEvent_Battle_ClientHandle_ClickAutoBattle(data)
   self._automaticBattle = data.isAutoBattle
end

function PVE_Config_Battle_Manager:handleEvent_Battle_ClientHandle_ClickChangeSpeed(data)
   self:setBattleSpeed(data.battleSpeed)

end

return PVE_Config_Battle_Manager

