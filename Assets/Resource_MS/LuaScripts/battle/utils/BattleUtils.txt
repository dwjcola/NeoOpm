---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2021/12/7 16:18
---@class BattleUtils
local BattleUtils = {}

function BattleUtils:getHeroInitOffsetPos(heroId,isLeft)
    if BattleConstant.HeroInitPos[heroId] then
        return isLeft and BattleConstant.HeroInitPos[heroId].l or BattleConstant.HeroInitPos[heroId].r
    else
        return isLeft and BattleConstant.HeroInitPos.Normal.l or BattleConstant.HeroInitPos.Normal.r
    end
end

function BattleUtils:posMapToVec3(map)
    if map and map[1] and map[2] and map[3] then
        return Vector3(map[1],map[2],map[3])
    else
        BattleLog.error("map 数据 不合法 ")
        BattleLog.errorTable(map)
        return Vector3.zero
    end
end

function BattleUtils:getPositionByIndex(isLeft,index)
    index = tonumber(index)
    local map = isLeft and BattleConstant.HeroInitPos_Main.left or BattleConstant.HeroInitPos_Main.right
    if index and  map[index] then
        return map[index]
    else
        BattleLog.error("数据 错误 ",isLeft,"  ",index)
    end

end

function BattleUtils:getHeroAssetPathByHeroId(heroId)
    --local heroInfo = ConfigReader:getDataByNameAndId("HeroInfo",heroId)
    --if heroInfo then
    --    return heroInfo.path
    --else
    --    BattleLog.error("HeroInfo 招不到数据 heroId == ",tostring(heroId))
    --    return ""
    --end
    if heroId == "hero101" then
        return "Assets/Resource_MS/Battle/General/prefab/bibidong_3.prefab"
    else
        return "Assets/Resource_MS/Battle/General/prefab/xulizhi_2.prefab"
    end

end

function BattleUtils:getSkillFrameList(heroId,skillTag)
    --todo 根据 heroId 和 skillTag 判断技能等级 对应的技能tag
    return {
        [10] = {
           frameType = 1,
           attackType = 1,
           value = 100,
        },
        [24] = {
            frameType = 1,
            attackType = 1,
            value = 100,
        },
        [41] = {
            frameType = 1,
            attackType = 1,
            value = 100,
        }

    }
end


function BattleUtils:getTestBattleData()
    local params = {
        isOnlyLogic = false,
        sceneData =  {},
        battleList = {
            {
                scenePath = "Assets/Resource_MS/Prefabs/Scenes/scene_root_test.prefab",
                rootPath = "Assets/Resource_MS/Prefabs/Scenes/playerRoot.prefab",
                battleType = Enum_Battle.BattleType.PVE_C,
                team_self = {
                    teamMap = {
                        --[1] = {
                        --    heroId = "hero101",
                        --},
                        [2] = {
                            heroId = "hero101",
                        },
                        --[3] = {
                        --    heroId = "hero101",
                        --},
                        [4] = {
                            heroId = "hero101",
                        },
                        --[5] = {
                        --    heroId = "hero101",
                        --}
                    },
                },
                team_enemy = {
                    blockId = "block_20_10",
                    teamMap = {
                        --[1] = {
                        --    heroId = "hero102",
                        --},
                        --[2] = {
                        --    heroId = "hero102",
                        --},
                        --[3] = {
                        --    heroId = "hero102",
                        --},
                        --[4] = {
                        --    heroId = "hero102",
                        --},
                        [5] = {
                            heroId = "hero102",
                        }
                    },
                }
            }
        }
    }
    return params
end


---@param oriVec Vector3
---@param tmpVec Vector3
---@param entityContext BattleEntityContext
function BattleUtils:handleTarget_place_r(oriVec,tmpVec,entityContext,camp,uid)
    --Logger.error(uid,"    ",oriVec,tmpVec)
    if tmpVec and oriVec.x == tmpVec.x and oriVec.y == tmpVec.y  then
        return false,tmpVec
    end
    if tmpVec == nil then
        tmpVec = oriVec
    end
    local self_entityList = entityContext:getEntityListByCamp(camp)
    local enemy_entityList = entityContext:getEnemyEntityList(camp)
    for i, entity in pairs(self_entityList) do
        if entity:getData()._uid ~= uid then
            local entity_pos = entity:getData()._position
            local place_r = entity:getData()._place_r
            local dis = Vector3.Distance(tmpVec,entity_pos)
            --Logger.error(dis)
            if dis < place_r then
                local tmpDic = tmpVec - entity_pos
                local tmp = BattleMathUtils.AngleAxis_Y_V3(tmpDic,-1)
                return self:handleTarget_place_r(oriVec,entity_pos + tmp,entityContext,camp,uid)
            end
        end
    end
    --for i, entity in pairs(enemy_entityList) do
    --    local entity_pos = entity:getData()._position
    --    local place_r = entity:getData()._place_r
    --    local dis = Vector3.Distance(tmpVec,entity_pos)
    --    if dis < place_r then
    --        local tmp = BattleMathUtils.AngleAxis_Y_V3(tmpVec,1)
    --
    --        return self:handleTarget_place_r(oriVec,tmp,entityContext,camp,uid)
    --    end
    --end
    return true,tmpVec
end

function BattleUtils:checkoutPosForPlace_r(oriVec,entityContext,camp,uid)
    local self_entityList = entityContext:getEntityListByCamp(camp)
    --local enemy_entityList = entityContext:getEnemyEntityList(camp)
    for i, entity in pairs(self_entityList) do
        if entity:getData()._uid ~= uid then
            local entity_pos = entity:getData()._position
            local place_r = entity:getData()._place_r
            local dis = Vector3.Distance(oriVec,entity_pos)
            --Logger.error(dis)
            if dis < place_r then
                return false
            end
        end
    end
    return true
end

return BattleUtils