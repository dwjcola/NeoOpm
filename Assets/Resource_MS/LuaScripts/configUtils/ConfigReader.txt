---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuyubao.
--- DateTime: 2021/11/25 11:44
---

local assert = _G.assert
local log =  function (tmp) LUAUIBase:Log(tmp) end
local error =  function (tmp) LUAUIBase:Error(tmp) end
local warning =  function (tmp) LUAUIBase:Warning(tmp) end

table.const = function() end
table.new = function()  return { } end

ConfigReader = {}


ConfigReader.indexfunc = function(t, k)
    return rawget(t, getmetatable(t)[k])
end
ConfigReader.newindexfunc = function(t, k)
    assert(false, "Readonly!!")
end

ConfigReader._Tables = {} -- 记录读取得数值表
ConfigReader._PreLoad = {} -- 记录预加载得数值表
ConfigReader._Loaded = {} -- 记录被拆分表中已加载的子表
ConfigReader._ExtendTable = {} -- 记录被拆分表中已加载的子表


local function compareNumber(num1,num2)
    if num1 == num2 then return 0 end
    return num1 > num2 and 1 or -1
end
local function compareStr(str1,str2)
    if str1 == str2 then return 0 end
    local len1 = #str1
    local len2 = #str2
    local len = len1 < len2 and len1 or len2
    for i = 1, len do
        local b1 = str1:byte( i, i )
        local b2 = str2:byte( i, i )
        if b1 ~= b2 then return b1 > b2 and 1 or -1 end
    end
    return len1 > len2 and 1 or -1
end

local function compareKey(key1,key2)
    if type(key1) == string then
        return compareStr(key1,key2)
    else
        Logger.Error(key1)
        Logger.Error(key2)
        return compareNumber(key1,key2)
    end
end
local function defcompre( v1, v2 )
    if v1==v2 then return 0 end
    return v1 > v2 and 1 or -1
end

local floor = math.floor

local function binfind( arr, value, compare)
    local startn = 1
    local endn = #arr
    compare = compare or defcompre
    while endn - startn > 1 do
        local n = floor((startn + endn)/2)
        local tmpV = arr[n]
        local com =  compare(value, tmpV)
        if com == 0 then return n end
        if com > 0 then startn = n end
        if com < 0 then endn = n end
    end
    local rend = arr[endn]
    local com = compare(value, rend)
    if com == 0 then return endn end
    if com > 0 then return endn+1 end
    local rstart = arr[startn]
    com = compare(value, rstart)
    if com >= 0 then return startn end
    return 0
end

function ConfigReader:getConfigName(tableName)
    --string.format("%s.%s", configPath, tableName)
  return tableName
end

function ConfigReader:getConfigPath(tableName)
    if self._configPath == nil then
        local config_dir = "config"
        self._configPath =  config_dir
    end
    return self._configPath
end

function ConfigReader:LoadPre( filename )
    local preload = self._PreLoad[filename]
    if not preload then
        preload = require( filename )
        self._PreLoad[filename] = preload
        table.const( preload )
    end
    return preload
end

function ConfigReader:tag2Filename(tableName, id)

    local tmpName = self:getConfigName(tableName)
    local preLoad = self:LoadPre(tmpName)
    local index = binfind( preLoad, id, compareKey )
    if preLoad[index] == id then return index end
    index = index + 1
    return preLoad[index] and index --防止超出
end

function ConfigReader:getRealInfoByData(value, extendTable)
    --if extendTable then
    --    local mt = getmetatable(value)
    --    if mt then
    --        mt.__index = function(t, k)
    --            if not rawget(t, getmetatable(t)[k]) then
    --                return self:getDataByNameIdAndKey(extendTable, value.type, k)
    --            else
    --                return rawget(t, getmetatable(t)[k])
    --            end
    --        end
    --    else
    --        mt = self:getDataByNameAndId(extendTable, value.type)
    --        setmetatable(value, mt)
    --    end
    --end

    return value
end

function ConfigReader:LoadSub( content, loadinfo, i, filename )
    --debug.forceinternstr( 1 )
    local ret = require(filename)
    table.const(ret, 1)
    --debug.forceinternstr( 0 )
    package.loaded[filename] = nil
    local extendTable = self._ExtendTable[filename]
    for k,v in pairs(ret) do
        content[k] = self:getRealInfoByData(v, extendTable)
    end
    loadinfo[i] = i
end

-- 将配置表添加到内存，如果没有id则添加所有小表，如果有id则添加id所在小表
function ConfigReader:getDataToMemory(tableName, id)

    local tmpName = self:getConfigName(tableName)

    --require变量表
    --self:LoadVar( tableName )

    --require表

    local preLoad = self:LoadPre(tmpName)
    if preLoad and preLoad.SPLIT_COUNT  then
        --已拆表
        local loadinfo = self._Loaded[tableName]
        if not loadinfo then
            loadinfo = table.new( 0, 16 )
            table.const(loadinfo)
            self._Loaded[tableName] = loadinfo
        end
        local content = self._Tables[tableName]
        if not content then
            content = table.new( 0, 16 )
            table.const(content)
            self._Tables[tableName] = content
        end
        if false then
            local i = self:tag2Filename( tableName, id )
            if i and not loadinfo[i] then
                self:LoadSub( content, loadinfo, i, tmpName.."_"..i )
            end
        else
            for i=1, #preLoad do
                --没id则加载所有子表，有id加载id所在子表(id此处为表中tag)
                if not loadinfo[i] then
                    self:LoadSub( content, loadinfo, i, tmpName.."_"..i )
                end
            end
        end
        self._Loaded[tableName] = loadinfo
        self._Tables[tableName] = content
    else
        self._Tables[tableName] = preLoad
    end
end

function ConfigReader:getDataTable(tableName)
    if not tableName then
        Logger.error(" 表 名不能为空")
        return
    end
    self:getDataToMemory(tableName)
    return self._Tables[tableName]
end

function ConfigReader:getDataByNameAndId(tableName, id)
    if not tableName or not id then
        return
    end
    --
    --if type(id) ~= "string" then
    --    id = tostring(id)
    --end
    local tableContent = self._Tables[tableName]
    local ret = nil
    if tableContent then
        ret = tableContent[id]
    end
    if ret == nil then
        self:getDataToMemory(tableName, id)
        tableContent = self._Tables[tableName]
        if tableContent then
            ret = tableContent[id]
        end
    end
    return ret
end

function ConfigReader:getDataByNameIdAndKey(tableName, id, key)
    local record = self:getDataByNameAndId(tableName, id)
    if record ~= nil then
        assert(type(record) == "table", "record is NOT table")
        return record[key]
    end
    return nil
end
--读取字典表
function ConfigReader:GetDicValue(key,...)
    local util = CS.GameFramework.Utility.Text
    local language = ConfigReader:getDataByNameAndId("Language",key)
    if language == nil then
        return key;
    end
    local content = language["language_zh"]
    return util.Format(content,...)
end